<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="None">
        
        
        <link rel="shortcut icon" href="img/favicon.ico">
        <title>ReCaS containers docs</title>
        <link href="css/bootstrap.min.css" rel="stylesheet">
        <link href="css/fontawesome.min.css" rel="stylesheet">
        <link href="css/brands.min.css" rel="stylesheet">
        <link href="css/solid.min.css" rel="stylesheet">
        <link href="css/v4-font-face.min.css" rel="stylesheet">
        <link href="css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body class="homepage">
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href=".">ReCaS containers docs</a>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#uso-di-immagini-apptainersingularity-con-htcondor-su-recas" class="nav-link">Uso di immagini Apptainer/Singularity con HTCondor su ReCaS</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#sec-introduzione" class="nav-link">Introduzione</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#sec-concetti-base" class="nav-link">Concetti di base: container, Apptainer e HTCondor</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#sec-organizzazione" class="nav-link">Organizzazione delle directory</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#sec-esempi" class="nav-link">Esempi</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#sec-docker-sif" class="nav-link">Costruzione di un’immagine Docker e conversione in SIF</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#sec-kubernetes" class="nav-link">Prospettive: uso di Kubernetes con container</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#appendice" class="nav-link">Appendice</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="uso-di-immagini-apptainersingularity-con-htcondor-su-recas">Uso di immagini Apptainer/Singularity con HTCondor su ReCaS<a class="headerlink" href="#uso-di-immagini-apptainersingularity-con-htcondor-su-recas" title="Permanent link">&para;</a></h1>
<h2 id="sec-introduzione">Introduzione<a class="headerlink" href="#sec-introduzione" title="Permanent link">&para;</a></h2>
<p>Questa guida descrive in modo operativo come usare immagini Apptainer/Singularity (file <code>.sif</code>) insieme a HTCondor sul cluster ReCaS. L’idea di fondo è che nel gruppo ci sia almeno un utente “manutentore” (che chiameremo <code>alice</code>) che possa costruire immagini Docker su una macchina dedicata (ad esempio una macchina con Docker come <code>tesla02</code>), convertirle in immagini Apptainer/Singularity e metterle a disposizione di tutti in una posizione condivisa su lustre. Gli altri utenti (ad esempio <code>bob</code>) non devono occuparsi della parte Docker: si limitano a usare le immagini <code>.sif</code> già pronte all’interno dei job Condor, tramite <em>symlink</em> verso la directory condivisa di <code>alice</code>.</p>
<p>Nel seguito useremo come esempio un utente chiamato <code>bob</code> per i job Condor, mentre <code>alice</code> rappresenterà l’utente manutentore che ospita le immagini condivise. Per rendere gli esempi concreti, si assume che siano già presenti due immagini Apptainer nella directory condivisa di <code>alice</code>:</p>
<pre><code class="language-bash">/lustrehome/alice/apptainer_images/G4_v10.6.3_NOMULTITHREAD.sif
/lustrehome/alice/apptainer_images/G4_v11.3.1.sif
</code></pre>
<p>Queste immagini contengono Ubuntu 24.04, Geant4, ROOT, Python3 con numpy e matplotlib. In particolare l’immagine <code>G4_v10.6.3_NOMULTITHREAD.sif</code> ha il multithreading disattivato per Geant4 ed è adatta ad applicazioni che richiedono esecuzione single-thread.</p>
<p>La sezione <a href="#sec-concetti-base">Concetti di base: container, Apptainer e HTCondor</a> introduce i concetti di base su container, Apptainer e HTCondor, mentre la sezione <a href="#sec-organizzazione">Organizzazione delle directory</a> propone una convenzione semplice per organizzare le directory su lustre dal punto di vista di <code>bob</code>. La sezione <a href="#sec-esempi">Esempi</a> illustra cinque esempi completi di utilizzo: test dell’immagine, build dell’esempio B5 di Geant4, run di B5, build+run in un unico job e un caso reale con una simulazione Geant di una tile scintillante tra due piani di fibre WLS (CsI-WLS) e Python. La sezione <a href="#sec-docker-sif">Costruzione di un’immagine Docker e conversione in SIF</a> mostra come costruire e convertire immagini Docker in <code>.sif</code>, mentre la sezione <a href="#sec-kubernetes">Prospettive: uso di Kubernetes con container</a> è prevista come estensione futura. In Appendice, la sezione <a href="#sec-dockerfile-esempio">Dockerfile di esempio per ambiente Geant4/ROOT</a> contiene un Dockerfile di esempio.</p>
<hr />
<h2 id="sec-concetti-base">Concetti di base: container, Apptainer e HTCondor<a class="headerlink" href="#sec-concetti-base" title="Permanent link">&para;</a></h2>
<p>Prima di entrare negli esempi conviene chiarire cosa si intende per container e come Apptainer interagisce con HTCondor nel contesto del cluster ReCaS.</p>
<p>Un container è un ambiente software isolato, definito da un’immagine che contiene un sistema operativo minimale (ad esempio Ubuntu), le librerie e le applicazioni necessarie. Quando si avvia un container, il programma viene eseguito con quell’ambiente software, indipendentemente dal sistema operativo del nodo fisico. Nel nostro caso un’immagine <code>.sif</code> contiene Geant4, ROOT, Python e le relative dipendenze, così che un job Condor non deve installare o configurare nulla: trova tutto già predisposto.</p>
<p>Su ReCaS i container sono gestiti da Apptainer (discendente di Singularity), progettato per ambienti HPC multiutente. Un’immagine Apptainer è un file in sola lettura; durante il job, Apptainer monta il filesystem dell’immagine e allo stesso tempo monta la directory di lavoro dell’utente, in modo che il programma possa leggere e scrivere i propri file su lustre. Questo approccio è più leggero di una macchina virtuale, perché il kernel del sistema è condiviso e si avvia solo lo strato utente.</p>
<p>HTCondor si occupa di individuare i worker node disponibili, preparare la directory di lavoro e avviare Apptainer. Dal punto di vista dell’utente, la cosa fondamentale è capire il ruolo di tre parametri nel file di submit: <code>initialdir</code>, <code>executable</code> e <code>container_image</code>.</p>
<ul>
<li>La direttiva <code>initialdir</code> indica la directory sul filesystem di lustre che rappresenta la cartella di lavoro del job. Condor monta questa directory nel container come current working directory (CWD), quindi tutto ciò che viene scritto in CWD o in sottocartelle relative finisce direttamente in questa directory su lustre.</li>
<li>La direttiva <code>executable</code> indica lo script o l’eseguibile che verrà lanciato all’interno del container. Deve trovarsi nella <code>initialdir</code> o in una sua sottocartella ed è specificato nel file di submit con un percorso relativo.</li>
<li>La direttiva <code>container_image</code> indica quale immagine Apptainer usare. I test effettuati sul cluster hanno mostrato un comportamento pratico importante: Condor si aspetta che il valore di <code>container_image</code> sia il nome di un file presente nella <code>initialdir</code>. Per questa ragione, anche se l’immagine “reale” vive in una directory centrale, per ogni job conviene creare nella <code>initialdir</code> un symlink locale all’immagine e poi usare nel submit il nome del symlink (ad esempio un symlink a <code>/lustrehome/alice/apptainer_images/immagine.sif</code>).</li>
</ul>
<p>Un esempio tipico è il seguente. Nella directory del job di <code>bob</code> si crea un link all’immagine condivisa di <code>alice</code>:</p>
<pre><code class="language-bash">ln -sf /lustrehome/alice/apptainer_images/G4_v11.3.1.sif \
       G4_v11.3.1.sif
</code></pre>
<p>e nel file di submit si scrive:</p>
<pre><code class="language-bash">container_image = G4_v11.3.1.sif
</code></pre>
<p>In questo modo Condor trova il file <code>G4_v11.3.1.sif</code> nella <code>initialdir</code>, avvia Apptainer con quell’immagine e monta la <code>initialdir</code> all’interno del container. Da quel momento in poi lo script <code>executable</code> viene eseguito dentro il container e la directory di lavoro corrisponde alla directory dell’utente su lustre.</p>
<p>Gli esempi pratici della sezione <a href="#sec-esempi">Esempi</a> non fanno altro che declinare questo schema base in casi d’uso via via più complessi.</p>
<hr />
<h2 id="sec-organizzazione">Organizzazione delle directory<a class="headerlink" href="#sec-organizzazione" title="Permanent link">&para;</a></h2>
<p>Per lavorare in modo ordinato conviene scegliere una convenzione semplice all’interno della propria home su lustre. Nel caso di <code>bob</code>, la directory di riferimento per i job è <code>/lustrehome/bob</code>, mentre l’utente manutentore <code>alice</code> usa <code>/lustrehome/alice</code> per ospitare le immagini condivise.</p>
<p>Le immagini Apptainer condivise dal manutentore possono essere raccolte in una directory dedicata, ad esempio <code>/lustrehome/alice/apptainer_images</code>. In questa directory si collocano i file <code>.sif</code> che <code>alice</code> ha costruito o recuperato. Nel nostro esempio vi si trovano <code>G4_v11.3.1.sif</code> e <code>G4_v10.6.3_NOMULTITHREAD.sif</code>.</p>
<p>Per gli esempi e i job Condor di <code>bob</code> si può usare una directory <code>condor_tests</code>. All’interno di <code>condor_tests</code> è utile creare sottodirectory dedicate per ciascun tipo di job. Ogni directory contiene i file di submit <code>.csi</code>, gli script <code>.sh</code>, un link locale all’immagine <code>.sif</code> (proveniente da <code>/lustrehome/alice/apptainer_images</code>) e una sottocartella <code>logs/</code> per gli output di Condor. Questa struttura rende chiaro dove si trova il codice sorgente, dove viene compilato il programma e dove finiscono i file prodotti dai job Condor, seguendo lo schema introdotto in <a href="#sec-concetti-base">Concetti di base: container, Apptainer e HTCondor</a> e utilizzato in tutti gli esempi successivi.</p>
<hr />
<h2 id="sec-esempi">Esempi<a class="headerlink" href="#sec-esempi" title="Permanent link">&para;</a></h2>
<p>In questa sezione sono riportati cinque esempi completi che illustrano come utilizzare immagini Apptainer/Singularity in combinazione con HTCondor. Gli esempi seguono un ordine progressivo, dal test più semplice fino a un caso realistico con un progetto Geant4 personalizzato:</p>
<ul>
<li><strong>Esempio <a href="#sec-esempio1">1</a></strong> – test minimale dell’immagine <code>.sif</code> per verificare la versione di Geant4, ROOT e Python e controllare che il container venga avviato correttamente su un worker node;</li>
<li><strong>Esempio <a href="#sec-esempio2">2</a></strong> – compilazione dell’esempio Geant4 B5 all’interno del container utilizzando CMake;</li>
<li><strong>Esempio <a href="#sec-esempio3">3</a></strong> – esecuzione di un binario Geant4 precompilato con una macro, in un job dedicato;</li>
<li><strong>Esempio <a href="#sec-esempio4">4</a></strong> – compilazione ed esecuzione dell’esempio B5 nello stesso job HTCondor, utile quando si vuole una build “pulita” per ogni run;</li>
<li><strong>Esempio <a href="#sec-esempio5">5</a></strong> – caso realistico con il progetto CsI-WLS, che prevede build con CMake e un batch di simulazioni pilotato da uno script Python.</li>
</ul>
<p>I template completi degli script <code>.sh</code> e dei file di submit <code>.csi</code> utilizzati negli esempi successivi sono disponibili al seguente link:</p>
<p><a href="https://politecnicobari-my.sharepoint.com/:f:/g/personal/m_cecca1_phd_poliba_it/IgB8X8DaFI3QTaVAEtIk1-7vAavKvy_XEBCvTr6rky2CQf8?e=si0j3J">https://politecnicobari-my.sharepoint.com/:f:/g/personal/m_cecca1_phd_poliba_it/IgB8X8DaFI3QTaVAEtIk1-7vAavKvy_XEBCvTr6rky2CQf8?e=si0j3J</a></p>
<hr />
<h3 id="sec-esempio1">Esempio 1: test dell'immagine Geant4<a class="headerlink" href="#sec-esempio1" title="Permanent link">&para;</a></h3>
<p>Il primo esempio ha lo scopo di verificare che l’immagine <code>G4_v11.3.1.sif</code> funzioni correttamente su un worker node. L’obiettivo è sapere su quale nodo gira il job, quali versioni di Geant4, ROOT e Python sono visibili dall’interno del container e se l’ambiente è coerente.</p>
<p>Si inizia creando la directory del test e una sottocartella per i log:</p>
<pre><code class="language-bash">cd /lustrehome/bob
mkdir -p condor_tests/test_container/logs
cd condor_tests/test_container
</code></pre>
<p>Si crea un link all’immagine condivisa di <code>alice</code>:</p>
<pre><code class="language-bash">ln -sf /lustrehome/alice/apptainer_images/G4_v11.3.1.sif \
       G4_v11.3.1.sif
</code></pre>
<p>Lo script <code>test_container.sh</code>, che sarà eseguito dentro il container, può essere definito come segue:</p>
<pre><code class="language-bash">#!/bin/bash
set -euo pipefail

echo &quot;[TEST] Start: $(date)&quot;
echo &quot;[TEST] Host:  $(hostname)&quot;
echo &quot;[TEST] User:  $(whoami)&quot;
echo &quot;[TEST] Pwd:   $(pwd)&quot;
echo

echo &quot;[TEST] Environment snippet:&quot;
echo &quot;  G4INSTALL=${G4INSTALL:-undefined}&quot;
echo &quot;  G4VERSION=${G4VERSION:-undefined}&quot;
echo &quot;  ROOTSYS=${ROOTSYS:-undefined}&quot;
echo

echo &quot;[TEST] Checking Geant4 / ROOT / Python...&quot;
command -v geant4-config  &gt;/dev/null 2&gt;&amp;1 &amp;&amp; \
  geant4-config --version || echo &quot;geant4-config NOT found&quot;
command -v root-config    &gt;/dev/null 2&gt;&amp;1 &amp;&amp; \
  root-config --version   || echo &quot;root-config NOT found&quot;
command -v python3        &gt;/dev/null 2&gt;&amp;1 &amp;&amp; \
  python3 --version       || echo &quot;python3 NOT found&quot;
echo

python3 - &lt;&lt; 'EOF'
import sys, platform
print(&quot;Python:&quot;, sys.version.split()[0])
print(&quot;Platform:&quot;, platform.platform())
EOF

echo
echo &quot;[TEST] Done: $(date)&quot;
</code></pre>
<p>Lo script va reso eseguibile:</p>
<pre><code class="language-bash">chmod +x test_container.sh
</code></pre>
<p>Il file di submit <code>test_container.csi</code> specifica la directory iniziale, lo script da eseguire e l’immagine da usare:</p>
<pre><code class="language-bash">universe        = vanilla

initialdir      = /lustrehome/bob/condor_tests/test_container

executable      = test_container.sh
arguments       =

container_image = G4_v11.3.1.sif

request_cpus    = 1
request_memory  = 1 GB
request_disk    = 4 GB

output          = logs/test_$(ClusterId).$(ProcId).out
error           = logs/test_$(ClusterId).$(ProcId).err
log             = logs/test_$(ClusterId).$(ProcId).log

queue 1
</code></pre>
<p>La sottomissione avviene con:</p>
<pre><code class="language-bash">condor_submit test_container.csi
</code></pre>
<p>Quando il job è completato, il file <code>logs/test_...out</code> contiene le informazioni stampate dallo script: il nome del worker node, l’utente, la directory di lavoro, le variabili di ambiente e le versioni dei software principali. Questo conferma che l’immagine è correttamente utilizzabile con HTCondor secondo lo schema introdotto in <a href="#sec-concetti-base">Concetti di base: container, Apptainer e HTCondor</a>.</p>
<hr />
<h3 id="sec-esempio2">Esempio 2: build dell’esempio B5 di Geant4<a class="headerlink" href="#sec-esempio2" title="Permanent link">&para;</a></h3>
<p>Il secondo esempio mostra come compilare l’esempio B5 di Geant4 usando l’immagine <code>G4_v11.3.1.sif</code>. L’obiettivo è ottenere l’eseguibile <code>exampleB5</code> in una directory di build gestita dal job.</p>
<p>Si crea la directory del test di build:</p>
<pre><code class="language-bash">cd /lustrehome/bob
mkdir -p condor_tests/build_B5_11.3.1/logs
cd condor_tests/build_B5_11.3.1
</code></pre>
<p>Si collega l’immagine condivisa:</p>
<pre><code class="language-bash">ln -sf /lustrehome/alice/apptainer_images/G4_v11.3.1.sif \
       G4_v11.3.1.sif
</code></pre>
<p>Lo script <code>build_B5_exec.sh</code> viene eseguito dentro il container e si occupa di configurare e compilare il progetto:</p>
<pre><code class="language-bash">#!/bin/bash
set -euo pipefail

echo &quot;[BUILD] Start: $(date)&quot;
echo &quot;[BUILD] Host:  $(hostname)&quot;
echo &quot;[BUILD] User:  $(whoami)&quot;
echo &quot;[BUILD] Pwd:   $(pwd)&quot;
echo

SRC_DIR=&quot;/opt/geant4/share/Geant4/examples/basic/B5&quot;
BUILD_DIR=&quot;B5_build_condor&quot;

echo &quot;[BUILD] SRC_DIR   = ${SRC_DIR}&quot;
echo &quot;[BUILD] BUILD_DIR = ${BUILD_DIR}&quot;
echo

if [[ -f /opt/geant4/bin/geant4.sh ]]; then
  echo &quot;[BUILD] Sourcing Geant4...&quot;
  source /opt/geant4/bin/geant4.sh
fi

if [[ -f /opt/root/bin/thisroot.sh ]]; then
  echo &quot;[BUILD] Sourcing ROOT...&quot;
  source /opt/root/bin/thisroot.sh
fi

mkdir -p &quot;${BUILD_DIR}&quot;
cd &quot;${BUILD_DIR}&quot;

echo &quot;[BUILD] Now in: $(pwd)&quot;

echo &quot;[BUILD] Running CMake...&quot;
cmake &quot;${SRC_DIR}&quot;

echo &quot;[BUILD] Building...&quot;
cmake --build . -- -j&quot;$(nproc)&quot;

echo
echo &quot;[BUILD] Done: $(date)&quot;
</code></pre>
<p>Lo script viene reso eseguibile:</p>
<pre><code class="language-bash">chmod +x build_B5_exec.sh
</code></pre>
<p>Il file di submit <code>build_B5_11.3.1.csi</code> è:</p>
<pre><code class="language-bash">universe        = vanilla

initialdir      = /lustrehome/bob/condor_tests/build_B5_11.3.1

executable      = build_B5_exec.sh
arguments       =

container_image = G4_v11.3.1.sif

request_cpus    = 4
request_memory  = 4 GB
request_disk    = 8 GB

output          = logs/build_$(ClusterId).$(ProcId).out
error           = logs/build_$(ClusterId).$(ProcId).err
log             = logs/build_$(ClusterId).$(ProcId).log

queue 1
</code></pre>
<p>Il job si sottomette con:</p>
<pre><code class="language-bash">condor_submit build_B5_11.3.1.csi
</code></pre>
<p>Al termine della compilazione, nella directory <code>/lustrehome/bob/condor_tests/build_B5_11.3.1/B5_build_condor</code> si trovano i file di CMake e l’eseguibile <code>exampleB5</code>. Lo standard output del job contiene i messaggi di CMake e l’esito del build, che verrà riutilizzato nella sezione <a href="#sec-esempio3">Esempio 3: run dell’esempio B5</a>.</p>
<hr />
<h3 id="sec-esempio3">Esempio 3: run dell’esempio B5<a class="headerlink" href="#sec-esempio3" title="Permanent link">&para;</a></h3>
<p>Il terzo esempio riutilizza l’eseguibile <code>exampleB5</code> compilato in <a href="#sec-esempio2">Esempio 2: build dell’esempio B5 di Geant4</a> e mostra come preparare una directory di run separata, in cui copiare l’eseguibile e le macro e lanciare la simulazione.</p>
<p>Si crea la directory per il run:</p>
<pre><code class="language-bash">cd /lustrehome/bob
mkdir -p condor_tests/run_B5_11.3.1/logs
cd condor_tests/run_B5_11.3.1
</code></pre>
<p>Si collega l’immagine:</p>
<pre><code class="language-bash">ln -sf /lustrehome/alice/apptainer_images/G4_v11.3.1.sif \
       G4_v11.3.1.sif
</code></pre>
<p>Si copiano l’eseguibile e la macro <code>run1.mac</code> dalla build:</p>
<pre><code class="language-bash">cp /lustrehome/bob/condor_tests/build_B5_11.3.1/B5_build_condor/exampleB5 .
cp /lustrehome/bob/condor_tests/build_B5_11.3.1/B5_build_condor/run1.mac .
</code></pre>
<p>Lo script <code>run_B5_exec.sh</code> lancia l’eseguibile con la macro:</p>
<pre><code class="language-bash">#!/bin/bash
set -euo pipefail

if [[ $# -lt 2 ]]; then
  echo &quot;Usage: $0 &lt;exec_rel_path&gt; &lt;macro_rel_path&gt;&quot;
  echo &quot;Example: $0 exampleB5 run1.mac&quot;
  exit 1
fi

EXEC_REL=&quot;$1&quot;
MACRO_REL=&quot;$2&quot;

echo &quot;[RUN] Start: $(date)&quot;
echo &quot;[RUN] Host:  $(hostname)&quot;
echo &quot;[RUN] User:  $(whoami)&quot;
echo &quot;[RUN] Pwd:   $(pwd)&quot;
echo &quot;[RUN] Exec:  ${EXEC_REL}&quot;
echo &quot;[RUN] Macro: ${MACRO_REL}&quot;
echo

if [[ -f /opt/geant4/bin/geant4.sh ]]; then
  echo &quot;[RUN] Sourcing Geant4...&quot;
  source /opt/geant4/bin/geant4.sh
fi
if [[ -f /opt/root/bin/thisroot.sh ]]; then
  echo &quot;[RUN] Sourcing ROOT...&quot;
  source /opt/root/bin/thisroot.sh
fi

EXEC_PATH=&quot;./${EXEC_REL}&quot;
MACRO_PATH=&quot;./${MACRO_REL}&quot;

if [[ ! -x &quot;${EXEC_PATH}&quot; ]]; then
  echo &quot;[RUN] ERROR: executable not found or not executable: ${EXEC_PATH}&quot;
  exit 1
fi
if [[ ! -f &quot;${MACRO_PATH}&quot; ]]; then
  echo &quot;[RUN] ERROR: macro not found: ${MACRO_PATH}&quot;
  exit 1
fi

echo &quot;[RUN] Launching: ${EXEC_PATH} ${MACRO_PATH}&quot;
&quot;${EXEC_PATH}&quot; &quot;${MACRO_PATH}&quot;

echo
echo &quot;[RUN] Done: $(date)&quot;
</code></pre>
<p>Lo script va reso eseguibile:</p>
<pre><code class="language-bash">chmod +x run_B5_exec.sh
</code></pre>
<p>Il file di submit <code>run_B5_11.3.1.csi</code> utilizza lo script, l’immagine e specifica le risorse richieste:</p>
<pre><code class="language-bash">universe        = vanilla

initialdir      = /lustrehome/bob/condor_tests/run_B5_11.3.1

executable      = run_B5_exec.sh
arguments       = exampleB5 run1.mac

container_image = G4_v11.3.1.sif

request_cpus    = 1
request_memory  = 2 GB
request_disk    = 4 GB

output          = logs/run_$(ClusterId).$(ProcId).out
error           = logs/run_$(ClusterId).$(ProcId).err
log             = logs/run_$(ClusterId).$(ProcId).log

queue 1
</code></pre>
<p>La sottomissione avviene come nei casi precedenti:</p>
<pre><code class="language-bash">condor_submit run_B5_11.3.1.csi
</code></pre>
<p>Gli output prodotti da B5 vengono scritti nella directory <code>/lustrehome/bob/condor_tests/run_B5_11.3.1</code>, che corrisponde alla directory di lavoro del job dentro il container, e rimangono quindi disponibili all’utente anche dopo la fine dell’esecuzione.</p>
<hr />
<h3 id="sec-esempio4">Esempio 4: build e run di B5 in un unico job<a class="headerlink" href="#sec-esempio4" title="Permanent link">&para;</a></h3>
<p>In alcune situazioni è comodo compilare il codice e far partire subito il run all’interno dello stesso job Condor. Questo permette di avere un singolo file di submit per l’intera catena e di garantire che il run utilizzi esattamente la build prodotta nel job.</p>
<p>Per questo esempio si crea una nuova directory:</p>
<pre><code class="language-bash">cd /lustrehome/bob
mkdir -p condor_tests/build_run_B5_11.3.1/logs
cd condor_tests/build_run_B5_11.3.1
</code></pre>
<p>Si collega l’immagine Geant4 11.3.1:</p>
<pre><code class="language-bash">ln -sf /lustrehome/alice/apptainer_images/G4_v11.3.1.sif \
       G4_v11.3.1.sif
</code></pre>
<p>Lo script <code>build_run_B5_exec.sh</code> esegue prima la compilazione dell’esempio B5 e subito dopo l’eseguibile con una macro di esempio:</p>
<pre><code class="language-bash">#!/bin/bash
set -euo pipefail

echo &quot;[BUILD+RUN] Start: $(date)&quot;
echo &quot;[BUILD+RUN] Host:  $(hostname)&quot;
echo &quot;[BUILD+RUN] User:  $(whoami)&quot;
echo &quot;[BUILD+RUN] Pwd:   $(pwd)&quot;
echo

SRC_DIR=&quot;/opt/geant4/share/Geant4/examples/basic/B5&quot;
BUILD_DIR=&quot;B5_build_condor&quot;
MACRO=&quot;${SRC_DIR}/run1.mac&quot;

echo &quot;[BUILD+RUN] SRC_DIR   = ${SRC_DIR}&quot;
echo &quot;[BUILD+RUN] BUILD_DIR = ${BUILD_DIR}&quot;
echo &quot;[BUILD+RUN] MACRO     = ${MACRO}&quot;
echo

if [[ -f /opt/geant4/bin/geant4.sh ]]; then
  echo &quot;[BUILD+RUN] Sourcing Geant4...&quot;
  source /opt/geant4/bin/geant4.sh
fi

if [[ -f /opt/root/bin/thisroot.sh ]]; then
  echo &quot;[BUILD+RUN] Sourcing ROOT...&quot;
  source /opt/root/bin/thisroot.sh
fi

mkdir -p &quot;${BUILD_DIR}&quot;
cd &quot;${BUILD_DIR}&quot;

echo &quot;[BUILD+RUN] Now in: $(pwd)&quot;

if [[ -x exampleB5 ]]; then
  echo &quot;[BUILD+RUN] exampleB5 already built, skipping CMake/cmake --build.&quot;
else
  echo &quot;[BUILD+RUN] Running CMake...&quot;
  cmake &quot;${SRC_DIR}&quot;

  echo &quot;[BUILD+RUN] Building...&quot;
  cmake --build . -- -j&quot;$(nproc)&quot;
fi

if [[ ! -x exampleB5 ]]; then
  echo &quot;[BUILD+RUN] ERROR: build failed, exampleB5 not found.&quot;
  exit 1
fi

echo
echo &quot;[BUILD+RUN] Running exampleB5 with macro: ${MACRO}&quot;
./exampleB5 &quot;${MACRO}&quot;

echo
echo &quot;[BUILD+RUN] ROOT files under $(pwd):&quot;
find . -maxdepth 3 -type f -name '*.root' -print || \
  echo &quot;[BUILD+RUN] Nessun .root trovato.&quot;

echo
echo &quot;[BUILD+RUN] Done: $(date)&quot;
</code></pre>
<p>Lo script viene reso eseguibile:</p>
<pre><code class="language-bash">chmod +x build_run_B5_exec.sh
</code></pre>
<p>Il file di submit <code>build_run_B5_11.3.1.csi</code> è il seguente:</p>
<pre><code class="language-bash">universe        = vanilla

initialdir      = /lustrehome/bob/condor_tests/build_run_B5_11.3.1

executable      = build_run_B5_exec.sh
arguments       =

container_image = G4_v11.3.1.sif

request_cpus    = 4
request_memory  = 4 GB
request_disk    = 8 GB

output          = logs/build_run_$(ClusterId).$(ProcId).out
error           = logs/build_run_$(ClusterId).$(ProcId).err
log             = logs/build_run_$(ClusterId).$(ProcId).log

queue 1
</code></pre>
<p>La sottomissione avviene con:</p>
<pre><code class="language-bash">condor_submit build_run_B5_11.3.1.csi
</code></pre>
<p>Alla conclusione del job, la directory <code>B5_build_condor</code> contiene sia i file generati da CMake, sia l’eseguibile <code>exampleB5</code>, sia i file di output del run (ad esempio file ROOT). Tutti questi file risiedono in <code>/lustrehome/bob/condor_tests/build_run_B5_11.3.1/B5_build_condor</code> e sono quindi accessibili per analisi successive.</p>
<hr />
<h3 id="sec-esempio5">Esempio 5: progetto CsI-WLS con Python<a class="headerlink" href="#sec-esempio5" title="Permanent link">&para;</a></h3>
<p>L’ultimo esempio mostra una situazione più vicina a un caso reale, in cui un’applicazione Geant4 custom (CsI-WLS) viene compilata da sorgente con CMake e poi eseguita molte volte con parametri diversi, gestiti da uno script Python. Per questo caso si sfrutta l’immagine <code>G4_v10.6.3_NOMULTITHREAD.sif</code>, che contiene Geant4 10.6.3 senza multithreading, ROOT 6.36.4 e Python3 con le librerie principali.</p>
<p>Si assume che il progetto CsI-WLS esista già in una directory di sviluppo, ad esempio <code>/lustrehome/bob/ADAPT/simulation/CsI-WLS_v1.2.2</code>, che contiene una sottodirectory <code>src</code> con i file CMake e il codice. Per rendere il job auto-contenuto dentro <code>condor_tests</code> si copia solo la directory <code>src</code>:</p>
<pre><code class="language-bash">cd /lustrehome/bob/condor_tests
mkdir -p CsI-WLS_v1.2.2
cp -r /lustrehome/bob/ADAPT/simulation/CsI-WLS_v1.2.2/src CsI-WLS_v1.2.2/
cd CsI-WLS_v1.2.2
mkdir -p logs
</code></pre>
<p>Si crea il link all’immagine senza multithreading di <code>alice</code>:</p>
<pre><code class="language-bash">ln -sf /lustrehome/alice/apptainer_images/G4_v10.6.3_NOMULTITHREAD.sif \
       G4_v10.6.3_NOMULTITHREAD.sif
</code></pre>
<p>Nella directory <code>source</code> (nel testo LaTeX originale si alternano <code>source</code>/<code>src</code>; qui assumiamo che lo script Python sia nella directory con i sorgenti) si definisce lo script Python che si aspetta di essere eseguito da dentro <code>build</code> (dove esiste <code>./CsI-WLS</code>). Questo script genera un certo numero di macro, ognuna con un seed diverso, e per ciascuna macro lancia l’eseguibile:</p>
<pre><code class="language-python">import numpy as np
import os
import matplotlib.pyplot as plt  # non usato, ma non da fastidio

DIR_MAC = &quot;./mac_electron&quot;
DIR_ROOT = &quot;rootOutput_electron&quot;

N_EVENTS = 10
subdir = &quot;random_rectangular_source_200keV&quot;
nfiles = 50

for k in range(nfiles):
    seed1, seed2 = np.random.randint(0, 2**32, size=2)

    mac = (f&quot;{DIR_MAC}/{subdir}/&quot;
           f&quot;random_rectangular_source_electron_ene_&quot;
           f&quot;200keV_ly1_n{k}.mac&quot;)
    root = mac.replace(DIR_MAC, DIR_ROOT).replace(&quot;.mac&quot;, &quot;&quot;)

    os.makedirs(os.path.dirname(mac),  exist_ok=True)
    os.makedirs(os.path.dirname(root), exist_ok=True)

    with open(mac, &quot;w&quot;) as f:
        f.write(
            &quot;/run/initialize\n&quot;
            &quot;/tracking/verbose 0\n&quot;
            &quot;/gps/particle e-\n&quot;
            &quot;/gps/position 0 0 0 mm\n&quot;
            &quot;/gps/direction 0 0 -1\n&quot;
            f&quot;/random/setSeeds [{seed1} {seed2}]\n&quot;
            &quot;/gps/pos/type Plane\n&quot;
            &quot;/gps/pos/shape Rectangle\n&quot;
            &quot;/gps/pos/halfx 220 mm\n&quot;
            &quot;/gps/pos/halfy 220 mm\n&quot;
            &quot;/gps/ene/mono 200 keV\n&quot;
            f&quot;/RunManager/NameOfOutputFile {root}\n&quot;
            f&quot;/run/beamOn {N_EVENTS}\n&quot;
        )

    os.system(f&quot;./CsI-WLS {mac}&quot;)

print(f&quot;\n {N_EVENTS*nfiles} eventi salvati in &quot;
      f&quot;{DIR_MAC}/{subdir} e simulati con ./CsI-WLS&quot;)
</code></pre>
<p>Questo file può essere salvato come <code>src/run_electrons_batch.py</code> (o <code>source/run_electrons_batch.py</code>, a seconda della struttura del progetto) all’interno della copia di CsI-WLS sotto <code>condor_tests</code>.</p>
<p>Nella root della directory <code>CsI-WLS_v1.2.2</code> si definisce lo script <code>run_CsI_WLS_electron_batch.sh</code>, che compila il progetto nella directory <code>build</code> e poi lancia lo script Python:</p>
<pre><code class="language-bash">#!/bin/bash
set -euo pipefail

echo &quot;[PYRUN] Start: $(date)&quot;
echo &quot;[PYRUN] Host: $(hostname)&quot;
echo &quot;[PYRUN] User: $(whoami)&quot;
echo &quot;[PYRUN] Pwd:  $(pwd)&quot;
echo

if [[ -f /opt/geant4/bin/geant4.sh ]]; then
  echo &quot;[PYRUN] Sourcing Geant4...&quot;
  source /opt/geant4/bin/geant4.sh
fi
if [[ -f /opt/root/bin/thisroot.sh ]]; then
  echo &quot;[PYRUN] Sourcing ROOT...&quot;
  source /opt/root/bin/thisroot.sh
fi

BUILD_DIR=&quot;build&quot;
SRC_DIR=&quot;source&quot;

mkdir -p &quot;${BUILD_DIR}&quot;
cd &quot;${BUILD_DIR}&quot;

echo &quot;[PYRUN] Now in build dir: $(pwd)&quot;

if [[ -x CsI-WLS ]]; then
  echo &quot;[PYRUN] CsI-WLS already built, skipping cmake/cmake --build.&quot;
else
  echo &quot;[PYRUN] Configuring with CMake...&quot;
  cmake &quot;../${SRC_DIR}&quot;

  echo &quot;[PYRUN] Building CsI-WLS...&quot;
  cmake --build . -- -j&quot;$(nproc)&quot;
fi

if [[ ! -x CsI-WLS ]]; then
  echo &quot;[PYRUN] ERROR: CsI-WLS binary not found after build.&quot;
  exit 1
fi

echo
echo &quot;[PYRUN] Running Python batch script...&quot;
python3 ../source/run_electrons_batch.py

echo
echo &quot;[PYRUN] ROOT files under rootOutput_electron/:&quot;
find rootOutput_electron -maxdepth 3 -type f -name '*.root' -print \
  || echo &quot;[PYRUN] Nessun .root trovato.&quot;

echo
echo &quot;[PYRUN] Done at $(date)&quot;
</code></pre>
<p>Lo script va reso eseguibile:</p>
<pre><code class="language-bash">chmod +x run_CsI_WLS_electron_batch.sh
</code></pre>
<p>Infine si definisce il file di submit <code>CsI_WLS_python_electrons.csi</code>:</p>
<pre><code class="language-bash">universe        = vanilla

initialdir      = /lustrehome/bob/condor_tests/CsI-WLS_v1.2.2

executable      = run_CsI_WLS_electron_batch.sh
arguments       =

container_image = G4_v10.6.3_NOMULTITHREAD.sif

request_cpus    = 1
request_memory  = 2 GB
request_disk    = 16 GB

output          = logs/pyCsI_$(ClusterId).$(ProcId).out
error           = logs/pyCsI_$(ClusterId).$(ProcId).err
log             = logs/pyCsI_$(ClusterId).$(ProcId).log

queue 1
</code></pre>
<p>La sottomissione avviene con:</p>
<pre><code class="language-bash">cd /lustrehome/bob/condor_tests/CsI-WLS_v1.2.2
condor_submit CsI_WLS_python_electrons.csi
</code></pre>
<p>Quando il job è terminato, nella directory <code>build</code> compaiono l’eseguibile <code>CsI-WLS</code>, le macro generate dallo script Python e gli output ROOT. Tutti questi file sono salvati su lustre dentro <code>/lustrehome/bob/condor_tests/CsI-WLS_v1.2.2</code>.</p>
<p>I template completi degli script <code>.sh</code> e dei file di submit <code>.csi</code> utilizzati negli esempi nella sezione <a href="#sec-esempi">Esempi</a> sono presenti al seguente link:</p>
<p><a href="https://politecnicobari-my.sharepoint.com/:f:/g/personal/m_cecca1_phd_poliba_it/IgB8X8DaFI3QTaVAEtIk1-7vAavKvy_XEBCvTr6rky2CQf8?e=si0j3J">https://politecnicobari-my.sharepoint.com/:f:/g/personal/m_cecca1_phd_poliba_it/IgB8X8DaFI3QTaVAEtIk1-7vAavKvy_XEBCvTr6rky2CQf8?e=si0j3J</a></p>
<hr />
<h2 id="sec-docker-sif">Costruzione di un’immagine Docker e conversione in SIF<a class="headerlink" href="#sec-docker-sif" title="Permanent link">&para;</a></h2>
<p>Gli esempi della sezione <a href="#sec-esempi">Esempi</a> assumono che le immagini <code>.sif</code> siano già disponibili in una cartella condivisa, gestita dall’utente <code>alice</code>. Questa sezione descrive in modo sintetico come costruire un’immagine Docker con Geant4, ROOT e Python, come convertirla in un’immagine Apptainer/Singularity e come distribuirla agli altri utenti, senza entrare nei dettagli dei singoli comandi di installazione del software all’interno del container.</p>
<p>La costruzione di immagini Docker richiede una macchina con Docker installato e accessibile, ad esempio le macchine come <code>tesla02.recas.infn.ba.it</code>. Un utente può connettersi a quella macchina con le stesse credenziali delle macchine di frontend <code>ui-al9.recas.infn.ba.it</code>, preparare un <code>Dockerfile</code> e costruire l’immagine. Un esempio completo di <code>Dockerfile</code> per un ambiente Ubuntu 24.04 con Geant4, ROOT e Python3 è riportato in appendice, nella sezione <a href="#sec-dockerfile-esempio">Dockerfile di esempio per ambiente Geant4/ROOT</a>.</p>
<p>Una volta scritto il <code>Dockerfile</code>, l’utente manutentore può costruire l’immagine con un comando del tipo:</p>
<pre><code class="language-bash">docker build -t registry-clustergpu.recas.ba.infn.it/alice/geant4:10.6.3 .
</code></pre>
<p>In seguito, l’immagine può essere inviata al registry interno, dove le credenziali sono le stesse del frontend:</p>
<pre><code class="language-bash">docker login registry-clustergpu.recas.ba.infn.it
docker push registry-clustergpu.recas.ba.infn.it/alice/geant4:10.6.3
</code></pre>
<p>La conversione da immagine Docker a immagine Apptainer/Singularity avviene su un nodo dove Apptainer è installato e autorizzato a eseguire il comando <code>build</code>. Un esempio di comando è:</p>
<pre><code class="language-bash">apptainer build G4_v10.6.3.sif \
  docker://registry-clustergpu.recas.ba.infn.it/alice/geant4:10.6.3
</code></pre>
<p>Il file <code>G4_v10.6.3.sif</code> così generato può essere copiato o spostato nella directory condivisa delle immagini:</p>
<pre><code class="language-bash">mv G4_v10.6.3.sif /lustrehome/alice/apptainer_images/
</code></pre>
<p>Dopo questo passaggio, tutti gli utenti (come <code>bob</code>) possono usare l’immagine nei propri job Condor creando un symlink nella <code>initialdir</code> e impostando <code>container_image</code> al nome del symlink, come mostrato nella sezione <a href="#sec-concetti-base">Concetti di base: container, Apptainer e HTCondor</a> e negli esempi.</p>
<h3 id="comandi-essenziali-docker">Comandi essenziali Docker<a class="headerlink" href="#comandi-essenziali-docker" title="Permanent link">&para;</a></h3>
<p>Non è necessario che ogni utente conosca Docker in dettaglio, ma è utile riassumere i comandi più usati nel ciclo di vita di un’immagine. La costruzione da <code>Dockerfile</code> nella directory corrente avviene di solito con:</p>
<pre><code class="language-bash">docker build -t nome_immagine:tag .
</code></pre>
<p>Per visualizzare le immagini locali si può usare:</p>
<pre><code class="language-bash">docker images
</code></pre>
<p>Per testare interattivamente un’immagine, ad esempio verificando che gli script di ambiente siano corretti, si può avviare un container con:</p>
<pre><code class="language-bash">docker run -it nome_immagine:tag
</code></pre>
<p>Infine, per taggare e inviare un’immagine verso il registry remoto, si possono usare comandi del tipo:</p>
<pre><code class="language-bash">docker tag nome_immagine:tag \
  registry-clustergpu.recas.ba.infn.it/alice/nome_immagine:tag

docker push registry-clustergpu.recas.ba.infn.it/alice/nome_immagine:tag
</code></pre>
<p>Questi comandi vengono eseguiti sulla macchina che ha Docker installato, come <code>tesla02.recas.infn.ba.it</code>.</p>
<h3 id="comandi-essenziali-apptainersingularity">Comandi essenziali Apptainer/Singularity<a class="headerlink" href="#comandi-essenziali-apptainersingularity" title="Permanent link">&para;</a></h3>
<p>Apptainer viene utilizzato sia per testare manualmente le immagini sia in maniera indiretta tramite HTCondor. Per un test rapido si può eseguire un comando dentro un’immagine <code>.sif</code> con:</p>
<pre><code class="language-bash">apptainer exec G4_v11.3.1.sif geant4-config --version
</code></pre>
<p>Per aprire una shell interattiva nel container si può usare:</p>
<pre><code class="language-bash">apptainer shell G4_v11.3.1.sif
</code></pre>
<p>La conversione da immagine Docker a <code>.sif</code> avviene, come già mostrato, con:</p>
<pre><code class="language-bash">apptainer build G4_v11.3.1.sif \
  docker://registry-clustergpu.recas.ba.infn.it/alice/geant4:11.3.1
</code></pre>
<p>I job Condor che usano <code>container_image</code> nascondono questi dettagli, perché è il sistema a chiamare internamente Apptainer. Tuttavia, conoscere questi comandi aiuta a testare rapidamente un’immagine su una macchina di frontend prima di costruire i file <code>.csi</code>, come quelli della sezione <a href="#sec-esempi">Esempi</a>.</p>
<hr />
<h2 id="sec-kubernetes">Prospettive: uso di Kubernetes con container<a class="headerlink" href="#sec-kubernetes" title="Permanent link">&para;</a></h2>
<p><em>(TODO)</em></p>
<p>Questa guida è focalizzata sull’uso di HTCondor e Apptainer per eseguire job batch su ReCaS. In prospettiva è possibile immaginare un’evoluzione verso l’uso di Kubernetes per l’orchestrazione dei container, ad esempio in contesti in cui il cluster offra un accesso nativo tramite <code>kubectl</code> e un insieme di <em>namespace</em> dedicati alla computazione scientifica.</p>
<p>L’idea di base sarebbe quella di mappare i concetti introdotti in questa guida sui costrutti di Kubernetes. Un job HTCondor che esegue un container diventerebbe un oggetto <em>Job</em> di Kubernetes, in cui il campo <code>image</code> dello <em>container spec</em> corrisponde all’immagine Docker/Apptainer usata attualmente in <code>container_image</code>. La nozione di <code>initialdir</code> verrebbe sostituita da un volume persistente (PersistentVolumeClaim) montato nel pod, su cui risiedono sorgenti, script e output. Gli script <code>.sh</code> utilizzati come <code>executable</code> in Condor verrebbero richiamati come <code>command</code> e <code>args</code> del container.</p>
<p>In una futura estensione di questa documentazione si potranno fornire esempi espliciti di manifest YAML per Kubernetes che riproducono gli stessi workflow illustrati qui: compilazione di un progetto Geant4 all’interno di un pod, esecuzione di simulazioni con macro, lancio di script Python per la generazione dei run e raccolta dei file ROOT su volumi condivisi. Sarà anche possibile discutere l’integrazione con sistemi di <em>job queue</em> più alti, che inviano richieste sia a HTCondor sia a Kubernetes a seconda del tipo di carico, mantenendo in comune lo stesso set di immagini container e directory di dati su storage condiviso.</p>
<hr />
<h2 id="appendice">Appendice<a class="headerlink" href="#appendice" title="Permanent link">&para;</a></h2>
<h3 id="sec-dockerfile-esempio">Dockerfile di esempio per ambiente Geant4/ROOT<a class="headerlink" href="#sec-dockerfile-esempio" title="Permanent link">&para;</a></h3>
<p>In questa sezione è riportato un esempio completo di <code>Dockerfile</code> per costruire un’immagine Docker basata su Ubuntu 24.04, con Geant4, ROOT e Python3. Questo file è pensato come base da adattare alle esigenze del gruppo, sia per quanto riguarda le versioni dei software, sia per i path di installazione. Il risultato atteso è un’immagine che espone gli script di environment <code>/opt/geant4/bin/geant4.sh</code> e <code>/opt/root/bin/thisroot.sh</code> e che può essere convertita in un file <code>.sif</code> come descritto nella sezione <a href="#sec-docker-sif">Costruzione di un’immagine Docker e conversione in SIF</a>.</p>
<pre><code class="language-docker">FROM ubuntu:24.04

LABEL author=&quot;marcocecca&quot;
LABEL version=&quot;G4v11.3.1_Rootv6.36.4_Ubuntu24&quot;

# ===========================
# Env Geant4 + ROOT (base)
# ===========================
ENV DEBIAN_FRONTEND=noninteractive TZ=Etc/UTC

ENV G4VERSION=11.3.1
ENV G4INSTALL=/opt/geant4
ENV G4DATA_DIR=$G4INSTALL/share/Geant4/data
ENV G4LIB_DIR=$G4INSTALL/lib
ENV G4GDMLROOT=$G4INSTALL

# ROOT
ENV ROOT_VERSION=6.36.04
ENV ROOTSYS=/opt/root

# ==========================================
# Dipendenze base (Qt5 + OpenGL/X11 + ROOT + Python + Vdt)
# ==========================================
RUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends \
    build-essential \
    cmake \
    git \
    pkg-config \
    ca-certificates \
    wget \
    curl \
    # Geant4 + GDML
    libxerces-c-dev \
    libexpat1-dev \
    # Qt5 + OpenGL + X11
    qtbase5-dev \
    qtbase5-dev-tools \
    qt5-qmake \
    libqt5opengl5-dev \
    libx11-dev \
    libxmu-dev \
    libxi-dev \
    libxrandr-dev \
    libxinerama-dev \
    libxcursor-dev \
    libgl1-mesa-dev \
    libglu1-mesa-dev \
    # runtime Qt/X11
    libxkbcommon-x11-0 \
    libfontconfig1 \
    libxrender1 \
    libxcb-icccm4 \
    libxcb-image0 \
    libxcb-keysyms1 \
    libxcb-render-util0 \
    libxcb-xfixes0 \
    libxcb-xinerama0 \
    # dipendenze ROOT
    libxpm-dev \
    libxft-dev \
    libssl-dev \
    libpcre3-dev \
    libgsl-dev \
    libgraphviz-dev \
    libtbb12 \
    libtbb-dev \
    libvdt-dev \
    # Python per gli script di simulazione
    python3 \
    python3-numpy \
    python3-matplotlib \
    python3-pip \
    # utility
    adduser \
 &amp;&amp; rm -rf /var/lib/apt/lists/*

# ================================
# Mandatory ReCaS: utente reale
# ================================
ENV USERNAME=alice
ENV USERID=000001
ENV GROUPID=1234

RUN groupadd -g &quot;$GROUPID&quot; &quot;$USERNAME&quot; &amp;&amp; \
    adduser --disabled-password --gecos '' --uid &quot;$USERID&quot; --gid &quot;$GROUPID&quot; &quot;$USERNAME&quot;

# ==========================================
# Sorgenti Geant4 11.3.1 (da GitLab CERN)
# ==========================================
RUN mkdir -p /opt/geant4-source /tmp/g4 &amp;&amp; \
    cd /tmp/g4 &amp;&amp; \
    wget https://gitlab.cern.ch/geant4/geant4/-/archive/v11.3.1/geant4-v11.3.1.tar.gz &amp;&amp; \
    tar -xzf geant4-v11.3.1.tar.gz -C /opt/geant4-source --strip-components=1 &amp;&amp; \
    rm -rf /tmp/g4

# ==========================================
# Build + install Geant4 (dataset inclusi)
# ==========================================
RUN mkdir -p /opt/geant4-build &amp;&amp; cd /opt/geant4-build &amp;&amp; \
    cmake ../geant4-source \
      -DCMAKE_INSTALL_PREFIX=${G4INSTALL} \
      -DGEANT4_BUILD_MULTITHREADED=ON \
      -DGEANT4_BUILD_CXXSTD=17 \
      -DGEANT4_INSTALL_DATA=ON \
      -DGEANT4_INSTALL_EXAMPLES=ON \
      -DGEANT4_USE_GDML=ON \
      -DGEANT4_USE_SYSTEM_EXPAT=ON \
      -DGEANT4_USE_SYSTEM_XERCESC=ON \
      -DGEANT4_USE_QT=ON \
      -DCMAKE_PREFIX_PATH=/usr/lib/x86_64-linux-gnu/cmake/Qt5 \
      -DGEANT4_USE_OPENGL_X11=ON \
      -DGEANT4_USE_XM=OFF \
      -DGEANT4_USE_RAYTRACER_X11=ON &amp;&amp; \
    cmake --build . -j&quot;$(nproc)&quot; &amp;&amp; \
    cmake --install . &amp;&amp; \
    rm -rf /opt/geant4-build

# =================================================
# Install ROOT (precompiled per Ubuntu 24.04)
# =================================================
RUN cd /opt &amp;&amp; \
    wget -O root.tar.gz https://root.cern/download/root_v6.36.04.Linux-ubuntu24.04-x86_64-gcc13.3.tar.gz &amp;&amp; \
    tar -xzf root.tar.gz &amp;&amp; \
    mv root root-${ROOT_VERSION} &amp;&amp; \
    ln -s root-${ROOT_VERSION} root &amp;&amp; \
    rm root.tar.gz

# =================================================
# Linker config + PATH/LD_LIBRARY_PATH globali
# =================================================
RUN echo &quot;${G4LIB_DIR}&quot;   &gt; /etc/ld.so.conf.d/geant4.conf &amp;&amp; \
    echo &quot;${ROOTSYS}/lib&quot; &gt; /etc/ld.so.conf.d/root.conf &amp;&amp; \
    ldconfig

ENV PATH=${G4INSTALL}/bin:${ROOTSYS}/bin:${PATH}
ENV LD_LIBRARY_PATH=${G4LIB_DIR}:${ROOTSYS}/lib

# ===========================
# Permessi su /opt/geant4
# ===========================
RUN chown -R &quot;$USERNAME:$GROUPID&quot; &quot;$G4INSTALL&quot;

# ======================================================
# EntryPoint: inizializza Geant4 + ROOT nel modo &quot;giusto&quot;
# ======================================================
RUN printf '%s\n' \
'#!/bin/bash' \
'set -e' \
'# --- Geant4 env ---' \
'G4_SH=&quot;${G4INSTALL}/bin/geant4.sh&quot;' \
'if [ -f &quot;$G4_SH&quot; ]; then' \
'  OLD_G4=&quot;$(pwd)&quot;' \
'  cd &quot;$(dirname &quot;$G4_SH&quot;)&quot;' \
'  . ./geant4.sh' \
'  cd &quot;$OLD_G4&quot;' \
'fi' \
'# --- geant4make (opzionale, per vecchi workflow) ---' \
'if [ -f &quot;${G4INSTALL}/share/Geant4-${G4VERSION}/geant4make/geant4make.sh&quot; ]; then' \
'  . &quot;${G4INSTALL}/share/Geant4-${G4VERSION}/geant4make/geant4make.sh&quot;' \
'fi' \
'# --- ROOT env ---' \
'if [ -f &quot;/opt/root/bin/thisroot.sh&quot; ]; then' \
'  OLD_ROOT=&quot;$(pwd)&quot;' \
'  cd /opt/root' \
'  . bin/thisroot.sh' \
'  cd &quot;$OLD_ROOT&quot;' \
'fi' \
'# --- Esegui il comando richiesto ---' \
'exec &quot;$@&quot;' \
&gt; /usr/local/bin/geant4-entrypoint.sh &amp;&amp; \
chmod +x /usr/local/bin/geant4-entrypoint.sh

WORKDIR /home/$USERNAME
USER $USERNAME

ENTRYPOINT [&quot;/usr/local/bin/geant4-entrypoint.sh&quot;]
CMD [&quot;bash&quot;]
</code></pre></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = ".",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="js/base.js"></script>
        <script src="search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>

<!--
MkDocs version : 1.6.1
Build Date UTC : 2025-11-29 14:09:34.079406+00:00
-->
